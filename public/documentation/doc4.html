<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/x-icon" href="../img/node-js-logo.png">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="../style/style.css" />
    <link rel="stylesheet" href="https://fonts.cdnfonts.com/css/oswald-4">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
    <script>
        function scrollToTop() {
            document.body.scrollTop = 0; /* For Safari */
            document.documentElement.scrollTop = 0; /* For Chrome, Firefox, IE, and Opera */
        }
    </script>
    <title>NodeJS Documentation</title>
</head>

<body>
    <header>
        <div>
            <h2 class="no-margin text-center"><strong>NodeJS Documentation</strong></h2>
        </div>
        <nav>
            <a href="/"><button class="btn nav-btn btn-success"><strong>Home</strong></button></a>
            <a href="/nodejs"><button class="btn nav-btn btn-success"><strong>NodeJS</strong></button></a>
            <div class="login-area">
                <a href="/admin"><button class="btn nav-btn btn-success"><strong>Admin</strong></button></a>
                <a href="/login"><button class="btn btn-success"><strong>Login</strong></button></a>
            </div>
        </nav>
    </header>
    <hr class="no-margin">
    <div class="container">
        <h1 class="text-center">Documentation | Page 4</h1><br>
        <p class="text-center">
        <div class="row btn-row">
            <div class="col-sm-4">
                <a href="/doc/3"><button class="btn btn-primary"><strong>Page 3</strong></button></a>
            </div>
            <div class="col-sm-4 text-center">
                <a href="/nodejs"><button class="btn btn-danger"><strong>Back</strong></button></a>
            </div>
            <div class="col-sm-4 text-right">
                <a href="/doc/5"><button class="btn btn-primary"><strong>Page 5</strong></button></a>
            </div>
        </div>
        <h3>CRUDable REST API</h3>
        <h4>GET Request</h4>
        <p>
            To make GET request endpoints for all and a single instance of a resource, this is the way to do it with
            error handling:
        </p>
        <pre><code class="js">const mountains = [
    { id: 1, name: "K2", height: 4675 },
    { id: 2, name: "Mt. Everest", height: 6162 },
    { id: 3, name: "Kilimanjaro", height: 5895 }
];

app.get("/mountains", (req, res) => {
    res.send({ data: mountains });
});

app.get("/mountains/:id", (req, res) => {
    const paramsMountainId = Number(req.params.id);
    if (!paramsMountainId) {
        res.send({ error: "The mountain id must be a number!" });
        return;
    }
    const foundMountain = mountains.find((mountain) => mountain.id === paramsMountainId);
    if (!foundMountain) {
        return res.status(404).send("Mountain not found!");
    }
    res.send({ data: foundMountain });
});</code></pre>
        <p>
            The endpoint for a single instance takes the id as a path variable to identify the resource to get.<br>
        </p>
        <h4>POST Request</h4>
        <p>
            To make a POST request endpoint, first you'll need to add this line at the top, after 'app' is initialized:
        </p>
        <pre><code class="js">app.use(express.json());</code></pre>
        <p>
            This adds middleware to the Express application. This middleware is responsible for parsing incoming JSON
            requests.
            When a client sends a JSON payload in the request body, this middleware will parse it and make it available
            as
            'req.body' in the route handlers.<br><br>
            Once that is added, you can make requests that require a body, such as POST.<br>
            Here is an example of a POST endpoint:
        </p>
        <pre><code class="js">app.post("/mountains", (req, res) => {
    mountains.push(req.body)
    res.send(req.body);
});</code></pre>
        <h4>PATCH Request</h4>
        <p>
            Modifies part of a resource. Like a POST request endpoint, this requires 'express.json()'.<br>
            The endpoint takes the id as a path variable to identify the resource to edit.<br>
            Here is an example of a PATCH request endpoint:
        </p>
        <pre><code class="js">app.patch("/mountains/:id", (req, res) => {
    const paramsMountainId = Number(req.params.id);
    if (!paramsMountainId) {
        res.send({ error: "The mountain id must be a number!" });
        return;
    }
    const updatedData = req.body;
    const foundMountain = mountains.find((mountain) => mountain.id === paramsMountainId);
    if (!foundMountain) {
        return res.status(404).send("Mountain not found!");
    }
    if (updatedData.name !== undefined) {
        foundMountain.name = updatedData.name;
    }
    if (updatedData.height !== undefined) {
        foundMountain.height = updatedData.height;
    }
    res.send(foundMountain);
});</code></pre>
        <h4>PUT Request</h4>
        <p>
            Modifies an entire resource. Like POST and PATCH request endpoints, this requires 'express.json()'.<br>
            The endpoint takes the id as a path variable to identify the resource to edit.<br>
            Here is an example of a PUT request endpoint:
        </p>
        <pre><code class="js">app.put("/mountains/:id", (req, res) => {
    const paramsMountainId = Number(req.params.id);
    if (!paramsMountainId) {
        res.send({ error: "The mountain id must be a number!" });
        return;
    }
    const updatedData = req.body;
    const foundMountain = mountains.find((mountain) => mountain.id === paramsMountainId);
    if (!foundMountain) {
        return res.status(404).send("Mountain not found!");
    }
    foundMountain.name = updatedData.name;
    foundMountain.height = updatedData.height;
    res.send(foundMountain);
});</code></pre>
        <h4>DELETE Request</h4>
        <p>
            Deletes a resource. <br>
            The endpoint takes the id as a path variable to identify the resource to delete.<br>
            Here is an example of a DELETE request endpoint:
        </p>
        <pre><code class="js">app.delete("/mountains/:id", (req, res) => {
    const paramsMountainId = Number(req.params.id);
    if (!paramsMountainId) {
        res.send({ error: "The mountain id must be a number!" });
        return;
    }
    const mountainIndex = mountains.findIndex((mountain) => mountain.id === paramsMountainId);
    if (mountainIndex === -1) {
        return res.status(404).send("Mountain not found!");
    }
    const deletedMountain = mountains.splice(mountainIndex, 1).pop();
    res.send(deletedMountain);
});</code></pre>
        <h3>Fetch</h3>
        <p>
            Fetch is a built-in function in JavaScript that allows you to make
            network requests to fetch resources, typically data, from a specified URL.
            It performs an asynchronous HTTP request.<br>
            Below is an example of the basic anatomy of a fetch GET request:<br>
        </p>
        <pre><code class="js">fetch("https://insert.url/here")
.then((response) => {
    if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
})
.then((data) => {
    console.log(data);
})
.catch((error) => {
    console.error("Fetch error:", error);
});</code></pre>
        <p>
            First, you specify the URL you want to fetch from, optionally you can provide the options of the
            request.<br>
            Then you check if your response was "OK". (HTML Status 200)<br>
            If it's "OK", then you return the response in .json format.<br>
            Then you can do something with the json data. In this case just writing to console.<br>
            You make sure to put a "catch", to handle any errors.<br><br>
            It can be very benefitial to put fetch in a standardized method, like this:<br>
        </p>
        <pre><code class="js">async function fetchGetJson(URL, token = null) {
    let options = {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
        },
    };
    if (token) {
        options.headers.Authorization = `Bearer ${token}`;
    }
    const data = await fetch(URL, options).then(handleHttpErrors);
    return data;
}

async function handleHttpErrors(res) {
    if (!res.ok) {
        const errorResponse = await res.json();
        const error = new Error(errorResponse.message);
        // @ts-ignore
        error.fullResponse = errorResponse;
        throw error;
    }
    return res.json();
}</code></pre>
        <p>
            This makes the code much more reusable, and includes an optional parameter for including a token, in case an
            endpoint requires authorization.<br>
            For functions doing HTTP requests, it is important to use async await, as it makes the asynchronous nature
            of fetch operate in a more synchronous-like way.<br>
            This means that any code following an async await function will not be executed until the response has been
            received by the HTTP request.<br>
        </p>
        <h3>Deployment</h3>
        <p>
            The process of deploying your application varies a lot depending on the service
            you decide on.
            Vercel is designed for serverless deployments, which means it's optimized
            for hosting static files and serverless functions. As a result you may run
            into problems trying to do some things.<br><br>
            Besides these limitations, it is very easy to set up a project with CI/CD on Vercel.
            You simply log in to the dashboard, click:<br>
            <i>"Add new" > "Project" > Select Git repository to import > Click "Deploy"</i><br>
            For this to work, you will need a "vercel.json" file in the root directory of the project.
            The .json file could look like this:
        </p>
        <pre><code class="json">{
    "version": 2,
    "builds": [
    {
        "src": "app.js",
        "use": "@now/node"
    }
    ],
    "routes": [
    {
        "src": "/(.*)",
        "dest": "app.js"
    }
    ]
}</code></pre>
        <p>
            "version": refers to the version of the Vercel configuration.<br>
            "builds": defines the build settings, it tells Vercel how to build the application and prepare for
            deployment.<br>
            > "src": defines the source file for the application, also known as the entry point.<br>
            > "use": tells Vercel to use a specific builder to build the project. In this case Node.<br>
            "routes": defines routing rules for the application, determining how incoming requests are handled.<br>
            > "src": here a regular expression is used to match all incoming paths.<br>
            > "dest": specifies destination for requests that match the source pattern, here directing them all to
            "app.js".<br><br>
        </p>
        <br>
        <div class="text-center">
            <button class="btn btn-success" onclick="scrollToTop()"><strong>Back to top</strong></button>
        </div>
        <br>
        </p>
    </div>
</body>

</html>